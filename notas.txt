Introducción al curso de bases de datos

	Historia de las Bases de Datos:

		- 1950-1960: Maquinas tabuladoras, tarjetas perforadas y cintas magnéticas.

		- 1960-1979: Modelos jerárquicos, discos duros, modelo de data relacional, transacciones en tiempo real.

		** Un disco duro tiene información persistente, o sea que perdura en el tiempo.

		- 1970-1980: SQL, Sistemas SQL comerciales, bases de datos paralelas y distribuidas, bases de datos
		  orientadas a objetos.

			** SQL es un estándar, la mayoría de los comandos básicos, en cualquier tipo de datos que sea SQL deben funcionar (MariaDB, MySQL, etc).

		- 1980-1990: Data mining, data warehouse, e-commerce.

		- 2000-Actualidad: XML, administración automatizada, analytics, big data, No SQL, InMemory, Scale Out,
		  Systems of Engagement.


	** Los datos no son información. Solo en el momento que creamos un reporte que contenga ciertos datos,
	   éstos se convierten en información.

	DBMS: Data Base Management System == SGBD: Sistemas de Gestión de Bases de Datos.


Tipos de bases de datos y sus aplicaciones en la industria.

	Las bases de datos se pueden dividir en:

		- Relacionales
		- No relacionales

	Bases de datos relacionales (empresariales):

		- DB2
		- SQL Server
		- Oracle

	Bases de datos relacionales (comunes):

		- MariaDB: Derivada de MySql 
		- PostgreSQL: Es una base de datos comunitaria pero tiene una versión enterprise que tiene soporte.

	Bases de datos no relacionales:

		 - Redis: Es una base de datos muy usada actualmente.
		 - neo4j: Es una base de datos basada en nodos. Esta centrada en grafos que nos va a permitir encontrar relaciones entre 
		 	objetos. Muy comun en ecommerce.
		 - Cassandra: Base de datos del proyecto Apache. Trabaja con grandes volumenes de datos.
		 - MongoDB: Base de datos noSQL que se basa en trabajar en varias instancias.

		– Bases de datos “Clave” – “Valor”: Es el modelo de NoSQL más popular y sencilla en cuanto a funcionalidad.
		– Bases de datos “Documentales”: Este tipo es el más versátil ya que guarda información como un documento generalmente de
		  tipo JSON o XML.
		– Bases de datos “En grafo”: La información representada en este tipo de bases de datos se realiza en forma de
		  nodos de un grafo y sus relaciones con las aristas del mismo.
		– Bases de datos “Orientadas a Objetos”: En este tipo de bases de datos la información se representa mediante objetos
		  de igual forma que lo hacen los lenguajes de programación orientados a objetos.

	Aplicaciones de Bases de Datos:

		- Hacer reservaciones, las cuales no redundan (repetir) en data (Aerolineas).
		- Tomar desiciones basados en un comportamiento histórico - registro de las notas - (Escuelas).
		- Realizar transacciones internas y externas (Bancos).
		- Registros distribuidos, usando bases de datos como fundamento (blockchain).
		- Registro de inventarios, compra, venta y relación con sus usuarios y clientes (Tiendas de Retail)
		- Inventario y Registro de producción (Manufactura)
		- Historial de empleados (Recursos Humanos)

	** Una base de datos no necesariamente puede ser un sistema unificado, también puede ser un sistema que se encuentre dentro
	de una sola infraestructura (o arquitectura) con instancias separadas.


Visión general de los datos
	
	Es algo que me permite describir un objeto. Este objeto global lo vamos a llamar 'Entidad'. 

	** Entidad: Es una abstracción del mundo real.
	** Relacion: Como se comportan las entidades con respecto a otras entidades.

		Ejemplo: Un vaso, el material del vaso es vidrio, el dato seria el material.

	Un dato por si solo no representa nada, para que represente algo debe ser explotado de forma correcta. Los datos se transforman en
	información cuando se les da sentido, cuando se les da un contexto.


	Diseño de bases de datos:

		- Niveles de abstracción:

			- Conceptual: Proceso de modelado de la base de datos basado objetos que se van a utilizar y sus caracteristicas. Se deben
			  tener en cuenta los conceptos de entidad / relación.

			- Lógico: Permite resolver dudas de consistencia que se generan en el nivel conceptual.

			- Físico: Aquí procedemos a implementar nuestra base de datos de la forma más eficiente posible al sistema de gestión de
			  bases de datos de nuestra elección. Es aquí donde llevamos nuestra estructura general a la forma requerida por el sistema
			  de gestión de bases de datos que elegimos para nuestro proyecto.

			  Un dato pueder ser de diferente tipo dependiendo de SGBD:

			  	Por ejemplo: en mi modelo tengo en dato CHAR pero el SGBD no usa tipos CHAR si no VARCHAR.


Tipos de datos

	- Caracteres: Pueden ser desde letras hasta caracteres especiales.
	- Numérico: Del 0 al 9 pero con una longitud especial.
	- Varchar: Caracteres con un formato más variable.
	- Imagen
	- Fecha: Generalmente van acompañadas de una hora.
	- Moneda: esto facilita todo si se trabaja con diferentes denominaciones.
	- Texto: Variables que tienen mayor tamaño que un char o que un varchar.
	- Bit: Se puede trabajar con 1 y 0 o también con verdadero y falso.
	- Decimal

	** La mayoría de estos tipos de datos se basan en el stándar SQL92, los cuales son aplicables a todas las bases de datos

	- Esquema = Es la estructura lógica que va a tener una Base de Datos
	- Instancia = Contenido de partículas que tiene una Base de Datos en un instante de tiempo.

	** Para poder modelar se debe describir:

		1. Datos.
		2. Relación entre los datos
		3. Restricciones de los datos

	Para hacer la descripción de la base de datos:

		1. DML: Data Manipulation Language o Lenguaje de Manipulación de Datos: Es un lenguaje procedimental y declarativo, contiene un
			conjunto de instrucciones que va ayudar en el proceso de construcción de la BD.

		2. DDL: Data Definition Language o Lenguaje de Definición de Datos: Especifico el esquema de la BD, generar diccionarios de 
			datos, las restricciones de integridad y las autorizacion para que ciertos usuarios no vean cierta data.

		3. SQL: Structured Query Language o Lenguaje de Consulta Estructurada

	Otros tipos de bases de datos:

		- Bases de datos relacionales.
		- Basadas en objetos relacionales.
		- XML
		- NoSQL
		- In-Memory


Diferentes tipos de bases de datos

	SQL:
		* Lenguaje estructurado
		* Esquemas de tablas
		* Integración con otros tipos de archivos
		* Indexación por medio de árboles: La indexación funciona como un indice de un libro o de un temario, nos dice donde encontramos
			un tema y en que pagina. La indexación en SQL se hace por medio de una estructura de arbol, esta nos permite hacer
			busquedas. Existe el problema que cuando se buscan tipos de datos que no estan necesariamente estructurados en una
			estructura de datos se busca desde el primer dato hasta el ultimo.
		* Scale Up: Crecimiento Vertical

		Ejemplos: PostgreSQL, MariaDB


	NoSQL:
		* Lenguaje estructurado
		* Lenguaje no estructurado
		* Diferente tipo de indexación, normalmente JSON:  no necesariamente funciona como un arbol, se pueden hacer indices
			dividiendo los objetos por sus caracteristica y particularidades.
		* Crecimiento horizontal

		Ejemplos: MongoDB, Cassandra


	Analiticas y de bigdata:
		* Lenguaje no estructurado.
		* Integración de muchos sistemas: Lo puedo integrar como a mi BD como a un filesystem
		* Sistemas tradicionales y de engagement: Como twitter, facebook, podemos necesitar datos de ellos pero es necesario bajar 
			toda la data de estos servicio.
		* Principo divide y venceras: dividir el problema en problemas más pequeños.
		* Basado en esquemas Scale out: crecimiento horizontal

		Ejemplos: Hadoop, Hortonworks, Spark


	Basadas en aceleración:
		Se crearon para solucionar el inconveniente que se presenta al querer realizar una busqueda en el esquema de arbol sobre una 
		inmensa cantidad de datos, donde la busqueda tomaria mucho tiempo.

		* Normalmente basadas In-Memory: son muy rapidas PERO no tienen persistencia.
		* Uso de aceleradores como GPU, Flash cards, FPGAs
		* Estructuras diferentes por ejemplo basadas en nodos.
		* Uso frecuente en ambientes empresariales productivos y de datawarehauose

		Ejemplos: Redis, neo4j, Kinetica.


	Formas de uso:
		* On premise, open source: Que corre en mi maquina local y no necesita una gran infraestructura para desplegarla.
		* Licenciamiento por cores y sockets: se paga dependiendo de ciertas características; como el hardware en el que va a correr.
		* Licenciamiento modular: se paga por funcionalidades o modulos para necesidades diferentes.
		* Pago por uso a través de SAAS (Software As A Service) ó PAAS (Platform As A Service): Es como adquirir una renta y pagar por
		  	usar una base de datos.
		* Suscripción de nodos de computo: funciona para plataformas como Hadoop el cual no es centralizado y trabaja de forma 
			distribuida, se paga por nodo utilizado.

*********
Datawarehose: es un repositorio unificado para todos los datos que recogen los diversos sistemas de una empresa.
	El repositorio puede ser físico o lógico y hace hincapié en la captura de datos de diversas fuentes sobre todo para fines
	analíticos y de acceso.

*********


Hadoop

	Espacio para averiguar sobre Hadoop



Que es una entidad?

	Entidad = Una abstracción del mundo real. Como en POO un objeto

	Notación Barker's: Notación para representar bases de datos (Entidades y Relaciones). 
		http://www.vertabelo.com/blog/technical-articles/barkers-erd-notation

	Recomendación: El formato para trabajar con los IDs debe ser "number". No siempre va a poder ser así, pero
	es lo más recomendable:

	Ejemplo: Vamos representar la entidad CASA

		 ___________________________
		|							|
		|		CASA 				|
		|							|
		|	# Número de ventanas    |---- number
		|	# Número de puertas     |---- number
		|	Color                   |---- character(30)
		|	ID                      |---- number
		|	Ubicación               |---- text
		|___________________________|



Que es una relación?

	Para definir una relación tenemos que tener en cuenta los siguientes puntos:

		* La obligatoriedad: Ésta se denota con una línea continua.
		* Opcional: Se representa con una linea punteada.

	La representación de la relación uno a muchos es con una pata de gallo


	0 - 1 ----------- (cero a uno: es obligatorio pero solo se puede tener uno)
	1 - 1 _______ (uno a uno: es obligatorio y solo se puede tener uno)
	0 - M ----------- ≡ (cero a muchos: no es obligatorio y se puede tener muchos)
	1 - M _______ ≡ (uno a muchos: es obligatorio y se puede tener muchos)
	M - M ≡ ----------- ≡ (muchos a muchos: no es obligatorio y se puede tener muchos)



Características o datos de una entidad

	** Los indices deben ser valores únicos y numéricos. Se recomienda que sean de tipo "numérico" porque estos
		tipos de datos son mas rápidos de encontrar por medio de una búsqueda, ya que solo hay 10 posibilidades
		(0 a 9) de comparación a diferencia de un tipo de dato caracter donde hay que hacer al rededor de 70 
		comparaciones.

	- Entidad Fuerte: La constituyen las tablas principales de la BD, que contienen los registros principales
		del sistema de información y que requieren de entidades o tablasauxiliares para completar su descripción
		o información.

	- Entidad Debil: Tablas auxiliares de una tabla principal a la que completan o complementan con la
		información de sus registros relacionados.

	¿Qué es un atributo?

		Los atributos de una entidad son las características que lo identifican o lo definen.


¿Ya aparecieron las llaves?

	Las llaves nos dan acceso a los datos de una entidad, su notación es la de numeral #.

	** Las llaves tienen que ser irrepetibles y obligatorias, por lo tanto el ID puede ser una llave.

	** Una llave puede ser compuesta, esta se compone de 2 numeros, entre ID y Numero de seguro social. (Como
		un numero de teléfono móvil).

	Llaves foraneas:
	** Las llaves foráneas son llaves que van a estar en nuestra tabla, que no necesariamente son nuestras llaves
		primarias pero van a permitir acceder a otra tabla donde ahí sean llaves primarias.
		Una llave foranea tiene que ser llave primaria de una tabla (entidad).

	Las llaves son fundamentales por que son obligatoriamente índices, los cuales permiten encontrar los datos
	cuando se necesitan de una forma rápida y ordenada.

	Tuplas: las tuplas están formadas por datos de varias columnas en la misma fila.
	Campo: El campo representa el tipo de dato.
	Fila: fila es la unión de todos esos diferentes tipos de datos correspondientes a un registro.



Indices e indexación

	Las llaves primarias siempre van ha ser indices
	Las bases de datos indexan bajo el algoritma 'Arboles B+': https://estructurasite.wordpress.com/arbol-b/

		   _______|_______		
		__|__   __|__   __|__
       |  |  | |  |  | |  |  |

       Es un arbol con un tranco y principal y del cual se desprenden 3 raices y de cada raíz otras 3.....

    Por defecto todas la bases de datos están indexadas asi NO tenga indices el primer atributo de una base de datos que se encuentra
    oculto se llama 'RowID'.

    Es importante que los indices sean numericos ya que la base de datos va a buscar la información siempre desde la primera rama (la
    que este más a la izquierda) y recorrera rama por rama hasta que encuentre lo que busca. Esto puede tarder mucho si el arbol es muy
    grande.


Constrains o Restricciones

	- Las restricciones se pueden trabajar desde la Base de Datos. Normalmente las validaciones con restricciones se hacen desde la
	  aplicación, pero se puede hacer desde la Base de Datos.

	- Las llaves primarias y las llaves foraneas no solamente tienen la restricción 'Not null', sino que además tienen la restricción
	  'unique', no puede haber otra igual.

	- Con 'check', las validaciones que podemos hacer son: Igual, mayor o igual, menor o igual, mayor qué o menor qué.



Capas de abstracción del modelo Entidad-Relación

	** Capa conceptual: En esta capa vamos a tener varias entidades, aún sin nombre definido. Las entidades van a tener cada una sus
	   llaves primarias y sus atributos, además van a tener relaciones. Para que existan las relaciones “muchos a muchos” se necesitan
	   llaves foráneas en las entidades.
         ________             ________            _______
	  	|		 |           |        |          |       |
		| Ent1   |≡---------≡| Ent2   |---------≡| Ent3  |
		|________|           |________|          |_______|


	** Capa logica: Para poder procesar las relaciones “muchos a muchos” las va a partir en entidades que se llaman: Entidades Débiles.
		Estas entidades debiles son intermedias como la "Ent1-2", y va a cambiar las relaciones: La Ent1 se va a relacionar 1 a M con Ent1-2 y Ent2 igual 1 a M con Ent1-2, para poder relacionarce la Ent1-2 debe tener una llaves (#) ver cuadro:



         ________                ________            ________
	  	|		 |              |        |          |        |
		| Ent1   |              | Ent2   |---------≡| Ent3   |
		| # Ent1 |              | # Ent2 |          | # Ent3 |
		|________|              |________|          |________|
            |                     |
			|		_________     |
			|	   |         |    |
			------≡| Ent1-2  |≡----
				   | # Ent1  |
                   | # Ent2  |
                   |         |
				   |_________|

        Para la relación Ent2 y Ent3 se necesita una llave foranea ya que es una relacion 1 a M entre dos entidades fuertes. Esta llave
        foranea se coloca en la entidad que recibe la pata de gallo:


       
         ________                ________            _________
	  	|		 |              |        |          |         |
		| Ent1   |              | Ent2   |---------≡| Ent3    |
		| # Ent1 |              | # Ent2 |          | # Ent3  |
		|________|              |________|          | *fk Ent2|
            |		              |                 |_________|
            |                     |
			|		_________     |
			|	   |         |    |
			------≡| Ent1-2  |≡----
				   | # Ent1  |
                   | # Ent2  |
                   |         |
				   |_________| 


		** Según el ejemplo: Tengo una entidad Usuarios (Ent1) y otra Rutas (Ent2) entonces un usuarios puede usar muchas rutas y
		una ruta puede ser usada por muchos usuarios. Para crear la relacion creamos la entidad debil (Ent1-2) en donde almacenamos 
		la relacion de esas rutas como los viajes que realiza el usuario, ademas puede tener otros atributos como el numero de silla
		que usó el usuario.

    ** Capa fisica: Este modelo va a ser el paso del modelo lógico hacia la representación que ya va a tener la Base de Datos.
    En esta capa, ya cada uno de los datos empieza a entrar en las clasificaciones según su tipo de dato. En este nivel las lineas de 
    las relaciones pasan ha ser flechas.



Metodología básica de 9 pasos con Barker (Paso 1) Identificar Cuáles son las Entidades Resuelven Nuestro Problema:
	
	** Documentarse muy bien acerca del problema que se va a resolver.

		- La entidad (o modelo) es nombrado en SINGULAR, la tabla se denomina en PLURAL.

		*** Una buena técnica para determinar de forma natural una entidad, es identificar aquellos elementos que poseen atributos que
		    los definen y que además aporta algo para definir el modelo del negocio. Definitivamente un elemento al que yo tenga que
		    forzarle sus atributos, no es una entidad. ***

    Ejemplos: Identificar la entidades de Aeropuertos:

    							- Avión
    							- Aerolinea
    							- Ruta
    							- Tripulante
    							- Piloto
    							- Aeropuerto
    							- País
    							- Ciudad
    							- Pasajero


Metodología básica de 9 pasos con Barker (Paso 2): Identificación de las Relaciones de las Entidades.

	** Pueden existir relaciones entre entidades que se relacione entre ellas mismas.


				| Avión	|Aerolinea 	|Ruta   |Tripulante	|Piloto	|Aeropuerto	|País 	|Ciudad	  |Pasajero
	Avión		|   *   |    1:1    |  1:M  |   1:M     |  1:M  |   1:M     |  *    |   *     |   1:M
	____________|_______|___________|_______|___________|_______|___________|_______|_________|___________
    Aerolinea   |   1:M |    *      |  1:M  |	  1:M   |  1:M  |   1:M     |  *    |   *     |   1:M  
    ____________|_______|___________|_______|___________|_______|___________|_______|_________|___________
    Ruta        |   1:M |   1:M     |   *   |     *     |   *   |    1:M    |  1:1  |   *     |    *
    ____________|_______|___________|_______|___________|_______|___________|_______|_________|___________
    Tripulante  |   1:1 |   1:1     |   *   |     *     |   *   |    *      |   *   |   *     |    *
    ____________|_______|___________|_______|___________|_______|___________|_______|_________|___________
    Piloto      |   1:1 |   1:1     |   1:M |     *     |   *   |    *      |   *   |   *     |    * 
    ____________|_______|___________|_______|___________|_______|___________|_______|_________|___________
    Aeropuerto  |   1:M |   1:M     |   1:M |     *     |   *   |    *      |   1:1 |   1:1   |    1:M
    ____________|_______|___________|_______|___________|_______|___________|_______|_________|___________
    País        |   *   |    *      |   1:M |    1:M    |   1:M |    1:M    |   *   |    *    |    1:M
    ____________|_______|___________|_______|___________|_______|___________|_______|_________|___________
    Ciudad      |   1:M |   1:M     |   1:M |    1:M    |  1:M  |   1:M     |   *   |    *    |    1:M
    ____________|_______|___________|_______|___________|_______|___________|_______|_________|___________
    Pasajero    |   1:1 |   1:M     |   1:M |    1:M    |  1:M  |    1:M    |   *   |    *    |     *



    ** Entidades Recursivas: Empleado: un empleado tiene un jefe , y a su vez el jefe tambien es un empleado de una empresa.



Metodología básica de 9 pasos con Barker (Paso 3): Entidades y Relaciones

	** Diagramar las entidades y las relaciones




Metodología de Diseño (Correcciónes del paso 2 y 3)

	En este ejemplo cuando la tabla de relaciones se divide por una diagonal quiere decir que son equivalentes, osea que en cada una
	de la relaciones de un lado y otro debe haber consistencia: No puede ser que en un lado haya una relación y en la otra no, no 
	importa si son diferentes relaciones lo que importa es que exitan en las dos o no de igual forma.

	Para tener muy encuenta:
	** Transitividad: Signfica que yo puedo llegar a una tabla desde una con la que este relacionada. No tiene que ser directamente,
		para evitar redundancia.

			Tengo: A --> B --> C
				  Yo puedo llegar de A a C porque estoy relacionado con B y B a su vez con C.



Metodología de Diseño (Paso 4): Asignar Atributos a las Entidades.

	Hasta este punto no nos vamos a fijar en que motor de base de datos vamos a correr.

	Para hacer un buen ejercicio hay que pensar en:

		- ¿Que atributos voy a necesitar?
		- ¿Cual va a ser la codificación que voy a utilizar?
		- ¿Como los voy a trabajar dependiendo del tipo de dato?
	    - El tipo de dato va a ser obligatorio o no obligatorio. Null o Not Nul
		- Vamos a tener un identificador único de cada tabla, una llave primaria. Mínimo una por tabla.
 		- Para hacer mas fácil las consultas hay que tener una nomenclatura para cada tabla (como AV_ para avión) y así poder
 	      referirnos a los atributos que se repiten en varias tablas (como nombre).
		- Hay que revisar el tipo de dato que vamos a usar, los identificadores se pueden trabajar como serial,
		 así la misma base de datos se va a encargar de que el valor de ese identificador sea único e irrepetible.
		- Definimos la obligatoriedad de los datos, las llaves primarias tienen que ser obligatorias.


Metodología de Diseño (Solución del paso 4): Terminando de Aseignar Atributos a las Entidades

	Revisar nuevamente los atributos creados para no tener errores



Metodología de Diseño (Pasos 5, 6 y 7) 5. Generar un diagrama conceptual, 6. Modelo lógico, 7. Identificar nuevos atributos
que generan nuestras entidades débiles.

	Paso 5: Generar un diagrama conceptual (entidades, relaciones y atributos). Las relaciones siempre se van a hacer en
			2 sentidos (A con B y B con A).

	Paso 6: Modelo lógico:
		Las relaciones se hacen por medio de entidades débiles, entre las entidades relacionadas, esto es porque no
		podemos generar muchas llaves foráneas en ambas entidades (fuertes).

		En estas entidades debiles se usan ambas llaves primarias de las entidades (fuertes) que tenían relación.

		En las entidades debiles no debería haber tipos de datos seriales, estas tendrían que ser integer,
		ya que las entidades debiles no tienen forma de tener consistencia con esa serialidad.

	Paso 7: Identificar nuevos atributos que generan nuestras entidades débiles.

		Por ejemplo un video en youtube puede ser visto por muchos usuarios y un usuario puede ver muchos videos, entonces creo la
		tabla intermedia con la relación uno a muchos con usuario y una a muchos con el video de youtube, luego en esta tabla
		intermedia pones un atributo timestamp para guardar cuando vio el video, otra puede ser cuantas veces vio el video, en
		que momento dejo de ver el video o pauso, datos que son exclusivos de la relación.


Metodología de Diseño (Paso 8): Construir el Diagrama del Modelo Físico

	Para identificar un modelo cuando lo vea y saber en que paso de la metodologia se encuentra:
		- Modelo Fisico : Lineas Rectas en las cajas de la entidad
		- Modelo Logico : Lineas Curvas en las cajas de la entidad

	- Las lineas de las relaciones van a ser lineas rectas, la relación uno a muchos vamos a crear una linea con un sentido que
	termina en cabeza de flecha. Las lineas 1 a 1 o 0 a 1 se mantienen como antes.

	- Las llaves foráneas en entidades debiles refieren o apuntan hacia su llave primaria en entidades fuertes.

	- En el modelo fisico hay que poner el tipo de dato de acuerdo a la base de datos en la que vamos a trabajar.



Metodología de Diseño (Paso 9): Pasar al estándar de la base de datos (SQL)

	Script clase 23



Reto con el paso 4 de la Metodología de Diseño



Atomicidad y consistencia

	A: atomicidad
	C: consistencia
	I: isolación / aislamiento
	D: durabilidad / persistencia

	Atomicidad: cuando para realizar una transacción esta depende de varios pasos (este conjunto de pasos son la 
				minima unidad para poder realizar la transacción) y si en alguno de los pasos se presentace un error
				se tiene que devolver todo a su estado inicial "Rollback".

	Consistencia: cuando se hace una transacción y esta tiene que pasar de un estado valido a otro estado valido.

				Ejemplo: Tengo una cuenta bancaria con un banco X y este banco no me permite tener menos de $10 en
						la cuenta y si yo quiero hacer una transferencia de 40 y mi saldo son 40 no podria porque la
						base de datos tendria una restricción.


Aislamiento y durabilidad

	Aislamiento: Permite que cada transacción sea independiente y no va a iniciar otra hasta que se haya hecho 
				commit de la primera.

	Durabilidad: Esta propiedad asegura que una vez realizada la operación, ésta persistirá y no se podrá deshacer
				 aunque falle el sistema y que de esta forma los datos sobrevivan de alguna manera.


Bases de datos In-Memory (Cambio de árboles a columnar) 

	Las bases de datos SQL (basadas en arboles) hacen una busqueda por cada uno de los campos de cada una de las
	filas hasta llegar al resultado. Por el contrario las bases de datos In-Memory (columnares) seleccionan una 
	columna y sobre ella realizan la busqueda.


	Ejemplo:

			          | In-Memory
			          |
			         \ /
			         ____________
					|  ID  | Nom | 
			        |______|_____|
			        |      |     |
          Arbol --->|  10  | abc |
			        |      |     |
				

Otros tipos de bases de datos de la industria

	Una base de datos orientada a grafos representa la información como nodos de un grafo y sus relaciones con las
	aristas del mismo, de manera que se pueda usar teoría de grafos para recorrer la base de datos ya que esta 
	puede describir atributos de los nodos (entidades) y las aristas (relaciones).



Bases de datos In-Memory con indexación columnar 
	
	http://www.oracle.com/technetwork/es/articles/database-performance/racle-database-12c-in-memory-2595521-esa.html


Definiendo el Proyecto y Generando Entidades de PlatziStore: Pasos 1 y 2

	Entidades PlatziStore:

		Item
		Cliente
		Método de compra
		Método de pago
		Proveedor
		Carrito

	Siempre hay que tratar de documentar una base de datos como si fuera código (con notas o comentarios), de esa
	manera sabemos porque tomamos ciertas decisiones en la estructura de la base de datos (relaciones, entidades).

	Podemos utilizar una notación para los métodos (mCompra y mPago), no hay que utilizar tildes aunque la base de
	datos acepte caracteres especiales no es recomendable debido a la diferente configuración en los teclados.

	Hay casos donde existen relaciones recursivas, es decir; cuando en una entidad existe relación con sigo
	misma (un jefe que tiene a su cargo otros jefes) dando así una relación jerárquica.

	Debido a la transitividad algunas entidades no se van a relacionar directamente unas con otras
	(cliente con item, mCompra y mPago) aunque si tengan relación.


Definir la Estructura de la Tabla Cliente del Proyecto: Pasos 3 y 4: (PlatziStore/clase31.xls)

	** Se recomienda usar el modelo de la hoja Definición. Para la definición de los modelos

	CHAR => Crea un espacio en memoria con el valor designado así no se use todo.
	VARCHAR => Crea un espacio en memoria con los caracteres ingresados y con el limite máximo que se designa.
	TIMESTAMP = año / mes / dia / hora


Terminando de Estructurar Nuestras Tablas (Continuación del paso 4): (PlatziStore/clase31.xls)

	Se recomienda nombrar los campos de las tablas colocando primero el nombre de la tabla + guion bajo + 
	nombre atributo

	Cliente_ID
	Cliente_cuentaPlatzi


Metodologia de diseño (Paso 5): Diagrama conceptual (platzistore/Paso 5 - Modelo Conceptual.png)

	Se diagrama las entidades y sus relaciones, pero esta vez las entidades van a tener sus atributos.

	** Las llaves primarias de denotan con: #
	** Los campos obligatorios se denotan con: *
	** Los campos obcionales se denotan con: o


Metodología de diseño (Paso 6 y 7): Modelo lógico y entidades debiles (platzistore/Paso-6-modelo logico.png)

	Paso 6 = Crear el modelo logico

	Las entidades debiles y entidades fuertes dependen de las relaciones que se tengan entre ellas:

	** La relacion muchos a muchos dentro de una base de datos no puede existir, por esto en el modelo logico
	lo que se debe hacer es 'romper las relaciones' creando entidades debiles y entidades fuertes:

		Ejemplo: Tengo dos entidades A y B que se relacionan muchos a muchos (estos son mis entidades fuertes), 
				para romper esta relación creo una tercera entidad que se va a llamar AB y cuyos atributos van
				ha ser las llaves primarias de las entidades fuertes:

				 A 		   				 B
				# a       				# b


							AB
						   # a
						   # b
						     c --> las entidades debiles pueden tener sus propios atributos

				Ahora la entidad A se va a relacionar uno a muchos con AB y de igual forma la entidad B con AB

	** En la relaciones uno a muchos (A a B respectivamente) las llaves foraneas de B son las llaves primarias de A

	** Los atributos que sean llaves primarias de las entidades fuertes y que sean seriales no pueden ser
		seriales en las entidades debiles, ya que en las entidades debiles se guardan las relaciones entre entidades
		fuertes. Para esto los (ID) se deben almacenar despues de creadas las entidades fuertes.

	Paso 7 = Crear las entidades debiles en la definicion de la BD clase31.xls - Definicion Paso 7 - Nuevos atributos en entidades débiles.pdf


Solución de atributos de entidad del proyecto - Atributos adicionales a entidad débil creada

	por convención las entidades débiles se nombran por orden alfabético, por ejemplo, carrito
	empieza por C mientras item empieza por I, por esta razón, la entidad débil se llama carrito-item y NO 
	item-carrito.


Metodología de Diseño (Paso 8) Paso 8 - Modelo Fisico.png
	
	Paso 8 = Modelo fisico

	* Las entidades ahora se llaman tablas
	* Las relaciones ahora se representan por flechas
	* La dirección de las flechas inician en la tabla que tiene la FK y apunta a la tabla que tiene la llave primaria

				FK
		FK -----------> PK

	* Dejamos de usar #, * y º para referinos a llaves primarias, campos obligatorios y opcionales.
	* Se definen los tipos de datos, dependiendo del motor SQL (MySQL, SQLServer, MariaDB, PostgreSQL).


Llevando nuestro proyecto a SQL (Paso 9) paso9_PlatziStore.sql

	** Usar los nombre de las tablas siempre en mayuscula

	create table PROVEEDOR
	(
    	PROV_ID              numeric(5,0) not null,
	   PROV_CODCC           varchar(15) not null comment 'Codigo Camara de Comercio',
	   PROV_NOMBRE          varchar(90) not null,
	   PROV_DESC            varchar(300) not null,
	   PROV_FECHAINI        timestamp not null,
	   PROV_FECHAUCOMPRA    timestamp,
	   PROV_MONTOUCOMPRA    numeric(7,0),
	   PROV_MONEDA          varchar(5),
	   primary key (PROV_ID, PROV_CODCC)
	);


	** Es posible colocar comentarios en la creacion de la base de datos para campos en particular


Dependencias funcionales
	
	* Reflexiva: (Una sola tabla) Si tengo un dato puedo obtener un dato B. Si tengo el numero de CC
				de una persona puedo obtener su nombre o apellido (si los datos estan en la misma tabla)

	* Aumentativa: se refiere que podemos usar tambien llaves foraneas para obtener datos de las otras tablas

	* Transitiva: Si tengo una tabla A que esta relacionada con una tabla B y tengo un tabla C relacionada 
				con B no tengo que tener relación entre A y C para poder traer los datos de C cuando hago
				una consulta de A.


Normalización, llevando el proyecto hasta tercera forma normal (primera forma normal)


	Principio de Atomicidad, dejar el mínimo valor posible de un dato:

		Por ejemplo en el atributo Nombre, el cual contiene nombres y apellidos, lo podemos segmentar en los
		atributos Nombre, Segundo Nombre y Apellidos. 

	** Para poder estar en la primera forma normal es necesario e indispensable que se tenga en cada 
		tabla una llave primaria ademas de tener todo en el mínimo valor posible.


Normalización, llevando mi proyecto hasta tercera forma normal (segunda forma normal)

	La regla de la Segunda Forma Normal (2FN) establece que todas las dependencias parciales se deben
	eliminar y separar dentro de sus propias tablas. Una dependencia parcial es un término que describe 
	a aquellos datos que no dependen de la clave de la tabla para identificarlos. 


	Tenemos una tabla inicial:

	identificacion	|	Primer nombre 	| Segundo nombre 	| Primer apellido 	|	Ciudad 		| 	Pais
		12345			Ana 				Maria 				Mesa 				Bogota			Colombia

	Si yo modifico la ciudad y la cambio por Lima el pais ya no seria Colombia (Esto es un problema si me
	olvida modificar tambien el pais)

	** Con la segunda forma normal independizo los datos creando una tabla para los datos de la persona, una para 
	las ciudades y otra para los paises:

	PERSONAS
	id 	| 	1 Nombre |	2 Nombre |	Apellido |	Cod_Ciudad


	CIUDADES
	cod_ciudad 	|	nombre 	| 	cod_pais


	PAISES 
	cod_pais 	|	nombre 


	Ahora son independientes y puedo modificar la ciudad de la persona sin afectar el pais.

	** La Tercera forma normal:
		dice que cada uno de los atributos que no sean claves dentro de la tabla pueden llegar a ser 
		candidatos a ser clave


Normalización, llevando mi proyecto hasta tercera forma normal (Cuarta y quinta forma normal)
	
	En 4FN obligatoriamente no podemos repetir datos en una tabla, solo tenemos combinaciones únicas y 
	todas las llaves van a poder ser si o si obligatoriamente llaves primarias.

	| 	ITEM 		| 	TALLA 	|	COLOR 	|
		camisa			XL 			blanco
		panatalon		L 			negro
		camisa			M 			azul
		playera			XL 			blanco


	En esta tabla se repiten los datos de todas las columnas (camisa, XL, blanco), para poner esto en 4FN
	se deben crear 3 tablas (ITEMS[id, descripcion], TALLAS[id, descripcion], COLORES[id, descripcion]	


	En 5FN es importante tener 2 tablas que están en 4FN, cada dependencia de union (join) va a estar 
	hecho por claves candidatas y no va puede estar hecho por condiciones que no se vayan a cumplir.


Comenzando con SQL

	Ventajas que da SQL:
	
	**Redundancia **: Eliminación de Renundancia de Datos
	Concurrencia : Posibilidad de accedes a datos de manera concurrente.
	Aislamiento: Permite realizar operaciones independientes
	Integridad: PK, not null, true , false o FK
	Inconsistencia: Permite evitar la insconsistencia de datos (Bogotá con tilde 
	en un registro, Bogota sin tilde en otro registro) refiriendose al mismo dato
	Seguridad: Autenticación, LDAP, Kerberos
	Acceso : Permite manejas esquemas de seguridad, ROLES ó noveles de accesos

	DML: DATA MODEL LANGUAGE
	DDL: DATA DEFINITION LANGUAGE


DDL: Data Definition Language y DML: Data Manipulation Languaje

	DDL (Data definition language): Son los comandos que sirven para crear o alterar o eliminar una tabla

		** create aplica a:

			create table 		# Permite crear una tabla.
			create view 		# Permite crear una vista.
			create procedure 	# Permite crear un proceso.
			create index 		# Permite crear un índice.
			create schema 		# Permite crear un esquema.

			** triggers = acciones que se activan en un momento en el tiempo
			** schema = conjunto de tablas que tienen algo en común. Un motor de base de datos puede tener varios 
						esquemas o bases de datos.

		** alter aplica a:

			alter table
			alter view
			alter prodecure


		** drop aplica a:

			drop table
			drop view


	DML (Data manipulation table)

		select 		# Permite seleccionar uno o muchos atributos de una o muchas tablas.
		join 		# Permite combinar registros de dos o más tablas.
		insert 		# Permite insertar en una table una nueva tupla.
		update 		# Permite actualizar uno o muchos atributos.
		delete 		# Permite eliminar uno o muchos atributos.
		replace 	# Permite actualizar un solo campo.


ACID desde lo no relacional

	A tomicity: Asegurar que la transacción se realice o no, sin quedar a medias ante fallos.
	C onsistency: Asegurar el estado de validez de los datos en todo momento.
	I solation: Asegurar independencia entre transacciones.
	D urability: Asegurar la persistencia de la transacción ante cualquier fallo.


CAP

	Consistency  : Consistencia
	Availability : Disponibilidad
	Partition 	 : Particionamiento

	** Las bases de datos noSQL funcionan con nodos (servidores o pc) que replican la información en todos los
		nodos, en caso de que se caiga un nodo los otros esten disponibles.

	C = Se espera que al consultar cualquier nodo obtenga un dato valido o la ultima versión de la información.
	A = Cuando haga una solicitud no me va a importar que nodo del sistema esta up time o down time o sin
		funcionamiento. Un dato debe estar replicado en al menos tres nodos.
	P = Es como yo parto esa información por lo menos en tres nodos para evitar que se pierdan mensajes. 
		Tolerancia a fallas.

	** Las bases de datos NoSQL están pensadas para ser escalables y distribuidas. 
		Por ser distribuidas tendremos que tener en cuenta el teorema CAP.

	** El teorema CAP, dice que en sistemas distribuidos es imposible garantizar a la vez: Consistencia,
	   Disponibilidad y Particionamiento.

		Para ser escalables y distribuidas, las bases de datos NoSQL, siguen distintos métodos, 
		por lo que no todas cumplen los mismos puntos del teorema CAP.

		Según las condiciones que cumplan se pueden tener:

		AP: garantizan Disponibilidad y Particionamiento, pero no la consistencia, al menos de forma total. 
			Algunas de ellas consiguen una consistencia parcial a través de la replicación y la verificación.

		CP: garantizan Consistencia y Particionamiento. Para lograr la consistencia y replicar los datos a 
			través de los nodos, sacrifican la disponibilidad.

		CA: garantizan Consistencia y Disponibilidad, pero tienen problemas con la tolerancia a particiones.
			Este problema lo suelen gestionar replicando los datos.


Scale Out y Scale Up
	
	En las bases de datos noSQL el procesamiento es mucho mas rapido que las relacionales tradicionales:

	Esto porque en las noSQL tengo la informacion repartida en varios nodos y cuando quiero buscar algo los nodos
	se activan al mismo tiempo y buscan la informacion muchos mas rapido al tener menos datos en los que buscar.
	En cambio en las relacionales el motor de base de datos tiene que buscar por los indices uno por uno.

	Ejercicio de las cartas !!!


¿Scale out o Scale up?

	Scale Up => Crecer con el mismo hardware, (memoria, procesador, etc).
	Scale Out => Escalamiento horizontal, mas maquinas con menores especificaciones.


DBMS en nube para poder iniciar una aplicación propia


Estructura básica de un Query 


Aprendiendo a Hacer más Querys


Estructura básica del Query con más de una tabla


Estructura básica del Query con más de una tabla 2


Tuplas y más tuplas
	
	En informática, o concretamente en el contexto de una base de datos relacional, un registro 
	(también llamado fila o tupla) representa un objeto único de datos implícitamente estructurados en una tabla

	El número de tuplas se denomina cardinalidad, la cardinalidad varía con el tiempo.


Insertar registros


Joins

	
Noo SQL Aplicado, Planteando el Problema

	RDBMS (DB relacionales): Escalabilidad vertical en una sola maquina
			Mejores niveles de servicio a nivel de bases de datos
			Sin embargo es limitado en crecimiento


	Estructuras tipo cluster:

							sharding
									 ___________
									|			|
									|___________|

										^	|
										|	v

									 ___________
									|			|  <--- Nodo maestro
		hash, llaves compartidas	|___________|
									  |	  |   |
					 _________________|   |   |_____________
					|					  |					|
					|                     |					|

					S1					  S2 				S3


	sharding = son paquetes o modulos que contienen partes de la BD (o replicas), estos permiten añadir mas shards
				con el fin de poder escalar.

				Los shards se comunican por medio de un nodo maestro que es el que contiene las llaves para
				permitir la comunicacion entre los shards


Aplicando NoSQL: Colecciones y Shards

	Colecciones : objetos principales de la Base de Datos no relacional, donde se pueden guarda la información
				  utilizando distintas llaves para acceder a datos.

		ejemplo (JSON):
			
			name : ‘Julieta’

	Pero la colección se debe especificarse en una ubicación, en un shard especifico.

	La información se puede distribuir en varios shards, esto incluye a que los datos de una colección
	pueden estar en 2 o mas shards.

	RAID 1 : Espejo de datos Nodo A es igual que en un Nodo B, se necesita mucha velocidad

				A>A
				A<A


	REPLICA : Mediante Replica, asegura alta disponibilidad
			
				B->B


	LOG: para averiguar como estaba la data en un determinado tiempo.
			
				Log 1 : valor 3
				Log 2: valor 4

			Quiere decir que surgio 1 dato modificado alterando el valor

	Snapshots (snaps) : Imagenes de un servidor, cluster, nodo, en un determinado momento. (para luego 
						restaurar o replicar la información en otro ambiente)



Aplicando noSQL: Integración de Comunicaciones y Hardware en una Base de Datos Scale OUT

	Variables a considerar en la administración en NoSQL:

	N numero de Replicas , Numero de Nodos (en hadoop recomienda 3 replicas, o más)
	W Numero de Replicas Exitosas para hacer Update (se debe esperar que sea 3 siempre y cuando tengas 3 nodos)
	R Replicas. Para consultar para lectura, cuantos nodos debo consultar para saber que la info es consistente.

	Formula
		W + R > N = Para que sea consistente


Aplicando noSQL: Integrando JSON a Bases de Datos No Relacionales
	

Conclusiones del curso
